ここまでの情報をもとに、アプリケーションを実装していきましょう。
実装には、AGENTS.mdに記載した通り、Kotlin, Spring Bootを用います。

まず、どのような実装を行えば確認できるのかの設計を検討していきます。
なるべくシンプルなものが良いですが、仕様案を提示してもらえますか？

```
• 仕様案

- API構成
    - POST /tenants：tenantId と zoneId（IANA ID）を登録。
    - POST /tenants/{id}/business-days：{ "date": "2025-11-01" } を受け取り、業務日付を LocalDate として保存しつつ、
      startInstant/endInstantExclusive を Instant で永続化。
    - GET /tenants/{id}/business-days/{date}：登録済み業務日の LocalDate と境界Instant、ZonedDateTime を返却。
- ドメインモデル
    - TenantSetting：tenantId・ZoneId。
    - BusinessDay 値オブジェクト：LocalDate・ZoneId を束ね、JSTなど任意TZで境界 Instant を計算。
    - 永続化：RDB（Spring Data JPA）で DATE + TIMESTAMP(UTC) 併存。
- 用途・検証
    - 同一日付でもTZ違いテナントの境界比較。
    - 日付入力→Instant変換→UTC保管→再表示でTZが保持されることを確認。
    - テナントごとの締め時刻（[start, endExclusive)判定）をドメインでテスト。
- 実装範囲
    - REST Controller → Application Service → Domain → Repository のDDDレイヤ構成。
    - 単純なIn-memory/DB実装から開始し、APIテストでTZ差と境界が確認できるようにする。
```

いったんマルチテナントのことは忘れましょう。アプリケーションはUTC、業務はJSTで行う前提で、業務タイムゾーンはDBに設定しておきそれを用いるということにしましょう。

```
• アプリ概要

- 目的: サーバ実行はUTCだが業務はJSTという前提で、「日付入力→UTC正規化→再表示」を一貫して確認できるシンプルなRESTアプ
  リを作る。
- 業務TZはDB設定で保持（単一レコード Asia/Tokyo）。アプリ起動時/処理時に参照し、日付境界計算に必ず利用。

API仕様

- GET /business-timezone
    - DB設定の業務TZ（例: "Asia/Tokyo"）を返す。環境差異の検証用。
- POST /business-days
    - 入力: { "date": "2025-11-01" }（文字列 ISO日付）。
    - 処理: LocalDate として受け取り、業務TZ(Asia/Tokyo)の [startOfDay, nextDayStart) をUTC Instant に変換して保存。
    - 応答: 登録結果の id, date, startInstant, endInstantExclusive, startZoned（JST）などを返し、境界確認。
- GET /business-days/{id}
    - 永続化済みデータを取得し、date, startInstant, endInstantExclusive, startZoned, endZoned を表示。
    - UTCとJST双方の見え方を返して整合性を確認。
- POST /business-days/contains（任意判定API）
    - 入力: "date": "2025-11-01", "timestamp": "2025-10-31T18:00:00Z" 等。
    - 処理: 業務日付の [start,end) に Instant が含まれるか判定。
    - 返却: {"contains": true/false}。JST境界をサーバ側で判断できることを示す。

ドメイン設計

- 値オブジェクト BusinessDate
    - フィールド: localDate: LocalDate, zone: ZoneId。
    - メソッド: startInstant(), endInstantExclusive(), contains(instant: Instant) など。
- エンティティ BusinessDayRecord
    - ID, date (LocalDate), startInstant, endInstantExclusive を保持。
- BusinessTimezoneSetting
    - 単一レコードの ZoneId。起動時ロードし、アプリ層にキャッシュ。

レイヤ構成

- Controller: RESTエンドポイント定義。
- Application Service: 業務TZの取得、BusinessDate生成、永続化呼び出し。
- Domain: 値オブジェクトで境界計算・判定ロジック。
- Infrastructure: Spring Data JPAによる BusinessDay/BusinessTimezone レポジトリ。H2などの組み込みDBで十分。

確認シナリオ

1. 業務TZがDB設定通り Asia/Tokyo であること。
2. 2025-11-01 登録→保存されたUTC境界が 2025-10-31T15:00:00Z と 2025-11-01T15:00:00Z になること。
3. contains 判定APIで 2025-11-01T14:59:59+09:00 は含む、2025-11-01T15:00:00+09:00 は含まない挙動を確認。
4. ログ・DB上はUTC、応答JSONは両方の表現で返り、ズレがない。

必要があれば、のちほどマルチテナント拡張やDST差異を検証できるよう、BusinessDate 値オブジェクトと設定リポジトリを抽象化
しておく。
```

webフロントエンドの実装も行ってほしいです。特に技術スタックは指定しないので今回の実装に適したものを検討してください。
フロントでは、日付入力を行い送信する、といった感じのもので良いですかね。
バリエーションとしては、

- 単一日付を入力する。これは当日一日の期間を意味する値
- 開始日と終了日を入力する

があればよさそうでしょうか？今までの議論から妥当であると思われる使用を提案してください。

```
• フロントエンド技術選定

  - React + Vite + TypeScript を採用。セットアップが速く、メンテしやすい。
  - 日付入力は Mantine や MUI の DatePicker、または react-day-picker を使えば UI 実装が容易。
  - 軽量な日付処理には date-fns を併用。

  画面・機能案

  - 「単一業務日」セクション：日付を1つ選択 → POST /business-days に { "date": "YYYY-MM-DD" } を送信。レスポンスの
    startInstant/endInstant をJST/UTC両方で表示し、境界のズレを見える化。
  - 「業務日範囲」セクション：開始日・終了日を入力 → POST /business-day-ranges に { "startDate": "...", "endDate":
    "..." } を送信。サーバで正規化した境界や日毎の区間を返し、画面で確認。
  - 任意機能（例示）：POST /business-days/contains により、指定したUTC時刻が業務日区間 [start, end) に含まれるか判定する
    テスターを設置すると挙動が理解しやすい。

  実装上の注意点

  - フロントは常に YYYY-MM-DD 文字列のままAPI送信し、ローカルタイムへの暗黙変換を行わない。
  - レスポンスは原文のJSONと整形表示（JST/UTC）を両方出し、確認しやすくする。
  - 日付範囲入力は start <= end を簡単にバリデーションし、無効な場合は送信不可にする。

  実装ステップ例

  1. バックエンドのAPI仕様（/business-days, /business-day-ranges, /business-days/contains）を確定。
  2. プロジェクト配下に frontend/ を作成し、Vite + React を初期化。共通APIクライアントとコンポーネントを実装。
  3. バックエンドのREST実装が整った段階で接続し、タイムゾーン計算が期待どおりか簡易テストやブラウザで確認。
```

